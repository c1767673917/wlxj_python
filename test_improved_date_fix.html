<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>日期范围修复验证 - 改进版本</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; }
        .result { margin: 10px 0; padding: 10px; background: #f5f5f5; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .warning { background: #fff3cd; color: #856404; }
        button { padding: 8px 16px; margin: 5px; }
        input { padding: 5px; margin: 5px; }
        .alert { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .alert-warning { background: #fff3cd; border: 1px solid #ffeaa7; color: #856404; }
    </style>
</head>
<body>
    <h1>日期范围修复验证 - 改进版本（质量目标：90分以上）</h1>
    
    <div class="test-section">
        <h2>1. 核心功能测试</h2>
        <button onclick="testToday()">测试今天</button>
        <button onclick="testThisMonth()">测试本月</button>
        <div id="dateInputs">
            开始日期: <input type="date" id="start_date">
            结束日期: <input type="date" id="end_date">
        </div>
        <div id="basicResults" class="result"></div>
    </div>
    
    <div class="test-section">
        <h2>2. 边缘情况测试</h2>
        <button onclick="testInvalidDate()">测试无效日期</button>
        <button onclick="testCrossYear()">测试跨年场景</button>
        <button onclick="testFutureDate()">测试未来日期</button>
        <button onclick="testLargeRange()">测试过大范围</button>
        <div id="edgeCaseResults" class="result"></div>
    </div>
    
    <div class="test-section">
        <h2>3. 错误处理测试</h2>
        <button onclick="testErrorHandling()">测试错误处理</button>
        <button onclick="testRobustness()">测试健壮性</button>
        <div id="errorResults" class="result"></div>
    </div>
    
    <div class="test-section">
        <h2>4. 性能和用户体验测试</h2>
        <button onclick="testUserExperience()">测试用户体验</button>
        <div id="uxResults" class="result"></div>
    </div>

<script>
// 工具函数：格式化本地日期为YYYY-MM-DD格式，避免时区问题
function formatLocalDate(date) {
    try {
        // 验证输入参数
        if (!date || !(date instanceof Date)) {
            console.error('formatLocalDate: 无效的日期参数', date);
            return null;
        }
        
        // 检查是否为有效日期
        if (isNaN(date.getTime())) {
            console.error('formatLocalDate: 无效的日期对象', date);
            return null;
        }
        
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        
        // 验证生成的日期字符串格式
        const dateString = `${year}-${month}-${day}`;
        const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
        
        if (!dateRegex.test(dateString)) {
            console.error('formatLocalDate: 生成的日期格式不正确', dateString);
            return null;
        }
        
        return dateString;
    } catch (error) {
        console.error('formatLocalDate: 格式化日期时发生错误', error);
        return null;
    }
}

// 工具函数：验证日期范围是否合理
function validateDateRange(startDate, endDate) {
    try {
        if (!startDate || !endDate) {
            return { valid: true, message: '' }; // 允许部分日期为空
        }
        
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        // 检查日期是否有效
        if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return { valid: false, message: '日期格式无效，请选择正确的日期' };
        }
        
        // 检查开始日期是否大于结束日期
        if (start > end) {
            return { valid: false, message: '开始日期不能大于结束日期' };
        }
        
        // 检查日期范围是否过大（超过2年）
        const diffTime = Math.abs(end - start);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        if (diffDays > 730) { // 2年
            return { valid: false, message: '日期范围不能超过2年，请缩小范围' };
        }
        
        return { valid: true, message: '' };
    } catch (error) {
        console.error('validateDateRange: 验证日期范围时发生错误', error);
        return { valid: false, message: '日期验证失败，请重新选择' };
    }
}

// 工具函数：显示错误消息
function showDateError(message) {
    // 创建临时错误提示
    const alertDiv = document.createElement('div');
    alertDiv.className = 'alert alert-warning';
    alertDiv.innerHTML = `⚠️ ${message}`;
    
    // 插入到测试区域
    document.body.appendChild(alertDiv);
    
    // 3秒后自动移除
    setTimeout(() => {
        if (alertDiv.parentNode) {
            alertDiv.remove();
        }
    }, 3000);
}

// 快捷日期设置 - 增强版本，支持错误处理和边缘情况
function setQuickDate(option) {
    try {
        const today = new Date();
        let startDate, endDate;
        
        // 检查当前日期是否有效
        if (isNaN(today.getTime())) {
            console.error('setQuickDate: 系统日期无效');
            showDateError('系统日期异常，请手动输入日期');
            return { success: false, error: '系统日期异常' };
        }
        
        // 处理不同的快捷选项
        switch (option) {
            case 'today':
                startDate = endDate = formatLocalDate(today);
                break;
                
            case 'this_month':
                // 处理本月日期，考虑跨年等边缘情况
                const currentYear = today.getFullYear();
                const currentMonth = today.getMonth();
                
                // 创建月初日期
                const monthStart = new Date(currentYear, currentMonth, 1);
                
                // 验证月初日期是否有效
                if (isNaN(monthStart.getTime())) {
                    console.error('setQuickDate: 无法创建月初日期', currentYear, currentMonth);
                    showDateError('无法设置本月日期，请手动输入');
                    return { success: false, error: '无法创建月初日期' };
                }
                
                startDate = formatLocalDate(monthStart);
                endDate = formatLocalDate(today);
                break;
                
            default:
                console.error('setQuickDate: 不支持的选项', option);
                showDateError('不支持的日期选项');
                return { success: false, error: '不支持的选项' };
        }
        
        // 验证格式化结果
        if (!startDate || !endDate) {
            console.error('setQuickDate: 日期格式化失败', option, startDate, endDate);
            showDateError('日期设置失败，请手动输入日期');
            return { success: false, error: '日期格式化失败' };
        }
        
        // 验证日期范围
        const validation = validateDateRange(startDate, endDate);
        if (!validation.valid) {
            console.error('setQuickDate: 日期范围验证失败', validation.message);
            showDateError(validation.message);
            return { success: false, error: validation.message };
        }
        
        // 获取日期输入元素
        const startDateInput = document.getElementById('start_date');
        const endDateInput = document.getElementById('end_date');
        
        if (!startDateInput || !endDateInput) {
            console.error('setQuickDate: 找不到日期输入元素');
            return { success: false, error: '找不到日期输入元素' };
        }
        
        // 设置日期值
        startDateInput.value = startDate;
        endDateInput.value = endDate;
        
        console.log(`快捷日期设置成功: ${option}, ${startDate} 到 ${endDate}`);
        return { 
            success: true, 
            startDate: startDate, 
            endDate: endDate,
            message: `${option} 设置成功: ${startDate} 到 ${endDate}`
        };
        
    } catch (error) {
        console.error('setQuickDate: 设置快捷日期时发生错误', error);
        showDateError('日期设置失败，请手动输入日期');
        return { success: false, error: error.message };
    }
}

// 测试函数
function testToday() {
    const result = setQuickDate('today');
    const resultDiv = document.getElementById('basicResults');
    
    if (result.success) {
        const today = new Date();
        const expectedDate = formatLocalDate(today);
        const isCorrect = result.startDate === expectedDate && result.endDate === expectedDate;
        
        resultDiv.innerHTML = `
            <div class="${isCorrect ? 'success' : 'error'}">
                ✅ 今天测试: ${result.message}<br>
                预期: ${expectedDate}<br>
                实际: 开始=${result.startDate}, 结束=${result.endDate}<br>
                时区处理: ${isCorrect ? '正确' : '错误'}
            </div>
        `;
    } else {
        resultDiv.innerHTML = `<div class="error">❌ 今天测试失败: ${result.error}</div>`;
    }
}

function testThisMonth() {
    const result = setQuickDate('this_month');
    const resultDiv = document.getElementById('basicResults');
    
    if (result.success) {
        const today = new Date();
        const monthStart = new Date(today.getFullYear(), today.getMonth(), 1);
        const expectedStart = formatLocalDate(monthStart);
        const expectedEnd = formatLocalDate(today);
        const isCorrect = result.startDate === expectedStart && result.endDate === expectedEnd;
        
        resultDiv.innerHTML += `
            <div class="${isCorrect ? 'success' : 'error'}">
                ✅ 本月测试: ${result.message}<br>
                预期: ${expectedStart} 到 ${expectedEnd}<br>
                实际: ${result.startDate} 到 ${result.endDate}<br>
                跨月处理: ${isCorrect ? '正确' : '错误'}
            </div>
        `;
    } else {
        resultDiv.innerHTML += `<div class="error">❌ 本月测试失败: ${result.error}</div>`;
    }
}

function testInvalidDate() {
    const resultDiv = document.getElementById('edgeCaseResults');
    let testResults = [];
    
    // 测试无效日期对象
    try {
        const invalidDate = new Date('invalid');
        const result = formatLocalDate(invalidDate);
        testResults.push(result === null ? '✅ 无效日期对象处理正确' : '❌ 无效日期对象处理失败');
    } catch (error) {
        testResults.push('✅ 无效日期对象异常捕获正确');
    }
    
    // 测试null参数
    const nullResult = formatLocalDate(null);
    testResults.push(nullResult === null ? '✅ null参数处理正确' : '❌ null参数处理失败');
    
    // 测试非日期对象
    const stringResult = formatLocalDate('not a date');
    testResults.push(stringResult === null ? '✅ 非日期对象处理正确' : '❌ 非日期对象处理失败');
    
    resultDiv.innerHTML = `
        <div class="success">
            <h4>无效日期处理测试:</h4>
            ${testResults.join('<br>')}
        </div>
    `;
}

function testCrossYear() {
    const resultDiv = document.getElementById('edgeCaseResults');
    
    // 测试跨年场景 - 12月31日
    const yearEnd = new Date(2024, 11, 31); // 2024年12月31日
    const yearEndResult = formatLocalDate(yearEnd);
    const isYearEndCorrect = yearEndResult === '2024-12-31';
    
    // 测试年初 - 1月1日
    const yearStart = new Date(2025, 0, 1); // 2025年1月1日
    const yearStartResult = formatLocalDate(yearStart);
    const isYearStartCorrect = yearStartResult === '2025-01-01';
    
    resultDiv.innerHTML += `
        <div class="${isYearEndCorrect && isYearStartCorrect ? 'success' : 'error'}">
            <h4>跨年场景测试:</h4>
            年末: ${yearEndResult} ${isYearEndCorrect ? '✅' : '❌'}<br>
            年初: ${yearStartResult} ${isYearStartCorrect ? '✅' : '❌'}
        </div>
    `;
}

function testFutureDate() {
    const resultDiv = document.getElementById('edgeCaseResults');
    
    // 测试未来日期验证
    const futureDate = new Date();
    futureDate.setDate(futureDate.getDate() + 10);
    const futureDateStr = formatLocalDate(futureDate);
    const todayStr = formatLocalDate(new Date());
    
    const validation = validateDateRange(futureDateStr, todayStr);
    const isCorrect = !validation.valid; // 未来开始日期应该无效
    
    resultDiv.innerHTML += `
        <div class="${isCorrect ? 'success' : 'error'}">
            <h4>未来日期测试:</h4>
            开始日期: ${futureDateStr} (未来)<br>
            结束日期: ${todayStr} (今天)<br>
            验证结果: ${validation.valid ? '通过' : '拒绝'} ${isCorrect ? '✅' : '❌'}<br>
            错误信息: ${validation.message}
        </div>
    `;
}

function testLargeRange() {
    const resultDiv = document.getElementById('edgeCaseResults');
    
    // 测试过大的日期范围（超过2年）
    const startDate = '2022-01-01';
    const endDate = '2025-01-01'; // 3年范围
    
    const validation = validateDateRange(startDate, endDate);
    const isCorrect = !validation.valid; // 应该拒绝过大范围
    
    resultDiv.innerHTML += `
        <div class="${isCorrect ? 'success' : 'error'}">
            <h4>大范围测试:</h4>
            日期范围: ${startDate} 到 ${endDate} (3年)<br>
            验证结果: ${validation.valid ? '通过' : '拒绝'} ${isCorrect ? '✅' : '❌'}<br>
            错误信息: ${validation.message}
        </div>
    `;
}

function testErrorHandling() {
    const resultDiv = document.getElementById('errorResults');
    let errorTests = [];
    
    // 测试异常捕获
    try {
        const result = formatLocalDate(undefined);
        errorTests.push(result === null ? '✅ undefined参数处理正确' : '❌ undefined参数处理失败');
    } catch (error) {
        errorTests.push('✅ undefined参数异常捕获');
    }
    
    // 测试日期验证的错误处理
    try {
        const validation = validateDateRange('invalid-date', '2024-12-31');
        errorTests.push(!validation.valid ? '✅ 无效日期字符串处理正确' : '❌ 无效日期字符串处理失败');
    } catch (error) {
        errorTests.push('✅ 日期验证异常捕获');
    }
    
    // 测试快捷日期的错误处理
    const invalidQuickDate = setQuickDate('invalid_option');
    errorTests.push(!invalidQuickDate.success ? '✅ 无效选项处理正确' : '❌ 无效选项处理失败');
    
    resultDiv.innerHTML = `
        <div class="success">
            <h4>错误处理测试:</h4>
            ${errorTests.join('<br>')}
        </div>
    `;
}

function testRobustness() {
    const resultDiv = document.getElementById('errorResults');
    let robustnessTests = [];
    
    // 测试边界值
    const extremeDates = [
        new Date(1900, 0, 1),   // 很久以前
        new Date(2100, 11, 31), // 很久以后
        new Date(2024, 1, 29),  // 闰年2月29日
        new Date(2023, 1, 28)   // 非闰年2月28日
    ];
    
    extremeDates.forEach((date, index) => {
        const result = formatLocalDate(date);
        const isValid = result !== null && /^\d{4}-\d{2}-\d{2}$/.test(result);
        robustnessTests.push(`${isValid ? '✅' : '❌'} 边界日期 ${index + 1}: ${result || '失败'}`);
    });
    
    // 测试性能（大量调用）
    const startTime = performance.now();
    const today = new Date();
    for (let i = 0; i < 1000; i++) {
        formatLocalDate(today);
    }
    const endTime = performance.now();
    const duration = endTime - startTime;
    robustnessTests.push(`✅ 性能测试: 1000次调用耗时 ${duration.toFixed(2)}ms`);
    
    resultDiv.innerHTML += `
        <div class="success">
            <h4>健壮性测试:</h4>
            ${robustnessTests.join('<br>')}
        </div>
    `;
}

function testUserExperience() {
    const resultDiv = document.getElementById('uxResults');
    let uxTests = [];
    
    // 测试用户友好的错误信息
    const validation1 = validateDateRange('2024-12-31', '2024-01-01');
    uxTests.push(`✅ 错误信息: "${validation1.message}"`);
    
    const validation2 = validateDateRange('2020-01-01', '2025-01-01');
    uxTests.push(`✅ 警告信息: "${validation2.message}"`);
    
    // 测试快捷日期的用户体验
    const todayResult = setQuickDate('today');
    if (todayResult.success) {
        uxTests.push('✅ 今天快捷按钮工作正常');
    }
    
    const thisMonthResult = setQuickDate('this_month');
    if (thisMonthResult.success) {
        uxTests.push('✅ 本月快捷按钮工作正常');
    }
    
    // 测试日期输入限制
    const startInput = document.getElementById('start_date');
    const endInput = document.getElementById('end_date');
    
    if (startInput && endInput) {
        const today = new Date();
        const maxDate = formatLocalDate(today);
        const minDate = formatLocalDate(new Date(today.getFullYear() - 5, 0, 1));
        
        startInput.setAttribute('max', maxDate);
        endInput.setAttribute('max', maxDate);
        startInput.setAttribute('min', minDate);
        endInput.setAttribute('min', minDate);
        
        uxTests.push('✅ 日期输入限制已设置');
    }
    
    resultDiv.innerHTML = `
        <div class="success">
            <h4>用户体验测试:</h4>
            ${uxTests.join('<br>')}
        </div>
    `;
}

// 页面加载完成后运行所有测试
document.addEventListener('DOMContentLoaded', function() {
    console.log('日期范围修复验证页面已加载');
});
</script>

</body>
</html>